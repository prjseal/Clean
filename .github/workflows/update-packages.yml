name: Update NuGet Packages

on:
  schedule:
    - cron: '30 10 * * *'  # Run daily at 10:30am UTC (10:30am UK time in winter, 11:30am in summer)
  workflow_dispatch:
    inputs:
      dryRun:
        description: 'Run without making changes'
        required: false
        default: 'false'
      includePrerelease:
        description: 'Include prerelease versions'
        required: false
        default: 'true'

env:
  # Change this to 'false' when you want scheduled runs to only use stable releases (e.g., when Umbraco 17 is officially released)
  SCHEDULED_INCLUDE_PRERELEASE: 'true'

jobs:
  update-packages:
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Install GitHub CLI
        run: |
          choco install gh -y

      - name: Update README with latest Umbraco 13 version
        id: update-readme
        shell: pwsh
        run: |
          Write-Host "================================================" -ForegroundColor Cyan
          Write-Host "Updating README with Latest Umbraco 13 Version" -ForegroundColor Cyan
          Write-Host "================================================" -ForegroundColor Cyan

          try {
            # Query NuGet API for the latest Umbraco 13.x version
            $packageId = "Umbraco.Cms.Web.Website"
            $nugetApiUrl = "https://api.nuget.org/v3-flatcontainer/$packageId/index.json"

            Write-Host "`nQuerying NuGet for latest Umbraco 13.x version..." -ForegroundColor Yellow

            $response = Invoke-RestMethod -Uri $nugetApiUrl -ErrorAction Stop
            $versions = $response.versions

            # Filter to only Umbraco 13.x versions
            $umbraco13Versions = $versions | Where-Object { $_ -match '^13\.' }

            if ($umbraco13Versions.Count -eq 0) {
              Write-Host "âš ï¸  No Umbraco 13.x versions found" -ForegroundColor Yellow
              exit 0
            }

            # Parse and sort versions to get the latest stable or prerelease
            $parsedVersions = $umbraco13Versions | ForEach-Object {
              $versionString = $_
              $prerelease = ""

              # Split on hyphen to separate version from prerelease tag
              if ($versionString -match '^([0-9]+\.[0-9]+\.[0-9]+)(.*)$') {
                $baseVersion = $matches[1]
                $prerelease = $matches[2]
              } else {
                $baseVersion = $versionString
              }

              # Create object for sorting
              [PSCustomObject]@{
                Original = $versionString
                Version = [Version]$baseVersion
                Prerelease = $prerelease
                IsPrerelease = $prerelease -ne ""
              }
            }

            # Sort by version (descending), then by prerelease status (stable first)
            $sortedVersions = $parsedVersions | Sort-Object -Property @{Expression={$_.Version}; Descending=$true}, @{Expression={$_.IsPrerelease}; Descending=$false}

            # Get the latest version
            $latestUmbraco13Version = $sortedVersions[0].Original

            Write-Host "Latest Umbraco 13.x version: $latestUmbraco13Version" -ForegroundColor Green

            # Update README.md with the new version for Umbraco 13 examples
            $readmePath = "README.md"
            if (Test-Path $readmePath) {
              Write-Host "`nUpdating README.md with version $latestUmbraco13Version for Umbraco 13 examples..."

              $readmeContent = Get-Content $readmePath -Raw
              $originalContent = $readmeContent

              # Extract the Umbraco 13 section (between "## Umbraco 13" and "---")
              $umbraco13Pattern = '(?s)(## Umbraco 13.*?)(---)'
              if ($readmeContent -match $umbraco13Pattern) {
                $umbraco13Section = $matches[1]
                $originalUmbraco13Section = $umbraco13Section

                Write-Host "Found Umbraco 13 section, applying updates..." -ForegroundColor Yellow

                # Pattern: Update Umbraco.Templates version for Umbraco 13
                $pattern0 = '(dotnet new install Umbraco\.Templates::)[\d\.]+-?[\w\d]*( --force)'
                if ($umbraco13Section -match $pattern0) {
                  $oldLine0 = $matches[0]
                  $umbraco13Section = $umbraco13Section -replace $pattern0, "`${1}$latestUmbraco13Version`${2}"
                  if ($umbraco13Section -match $pattern0) {
                    $newLine0 = $matches[0]
                    if ($oldLine0 -ne $newLine0) {
                      Write-Host "  BEFORE: $oldLine0" -ForegroundColor Yellow
                      Write-Host "  AFTER:  $newLine0" -ForegroundColor Green
                    } else {
                      Write-Host "  No change needed - already at version $latestUmbraco13Version" -ForegroundColor Cyan
                    }
                  }
                } else {
                  Write-Host "  Warning: Could not find Umbraco.Templates pattern in Umbraco 13 section" -ForegroundColor Yellow
                }

                # Replace the Umbraco 13 section in the full content
                if ($originalUmbraco13Section -ne $umbraco13Section) {
                  $readmeContent = $readmeContent -replace [regex]::Escape($originalUmbraco13Section), $umbraco13Section
                  Write-Host "  Section was modified, updating README..." -ForegroundColor Green
                } else {
                  Write-Host "  Section unchanged" -ForegroundColor Cyan
                }
              } else {
                Write-Host "Warning: Could not find Umbraco 13 section in README.md" -ForegroundColor Yellow
              }

              if ($readmeContent -ne $originalContent) {
                Set-Content -Path $readmePath -Value $readmeContent -NoNewline
                Write-Host "`nâœ… README.md updated successfully with version $latestUmbraco13Version" -ForegroundColor Green
                echo "readme_updated=true" >> $env:GITHUB_OUTPUT
              } else {
                Write-Host "`nâ„¹ï¸  README.md already has the correct version or no changes were needed" -ForegroundColor Yellow
                echo "readme_updated=false" >> $env:GITHUB_OUTPUT
              }
            } else {
              Write-Host "Warning: README.md not found at $readmePath" -ForegroundColor Yellow
              echo "readme_updated=false" >> $env:GITHUB_OUTPUT
            }

            Write-Host "`n================================================" -ForegroundColor Cyan
            Write-Host "README update complete" -ForegroundColor Green
            Write-Host "================================================" -ForegroundColor Cyan

          } catch {
            Write-Host "âš ï¸  Error updating README: $_" -ForegroundColor Yellow
            Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Yellow
            Write-Host "Continuing with workflow..." -ForegroundColor Yellow
            echo "readme_updated=false" >> $env:GITHUB_OUTPUT
          }

      - name: Run UpdateThirdPartyPackages script
        id: update-packages
        shell: pwsh
        run: |
          $dryRunFlag = if ('${{ github.event.inputs.dryRun }}' -eq 'true') { $true } else { $false }

          # Determine if this is a scheduled run or manual trigger
          $isScheduled = '${{ github.event_name }}' -eq 'schedule'

          # For manual runs, use the includePrerelease input
          # For scheduled runs, use the SCHEDULED_INCLUDE_PRERELEASE environment variable
          if ($isScheduled) {
            $includePrereleaseFlag = if ('${{ env.SCHEDULED_INCLUDE_PRERELEASE }}' -eq 'false') { $false } else { $true }
            Write-Host "Scheduled run - using SCHEDULED_INCLUDE_PRERELEASE env variable" -ForegroundColor Cyan
          } else {
            $includePrereleaseFlag = if ('${{ github.event.inputs.includePrerelease }}' -eq 'false') { $false } else { $true }
            Write-Host "Manual run - using includePrerelease input" -ForegroundColor Cyan
          }

          Write-Host "DryRunFlag = $dryRunFlag"
          Write-Host "IncludePrereleaseFlag = $includePrereleaseFlag"
          ./.github/workflows/powershell/UpdateThirdPartyPackages.ps1 `
            -RootPath "${{ github.workspace }}" `
            -DryRun:$dryRunFlag `
            -IncludePrerelease:$includePrereleaseFlag

      - name: Check if any changes were made
        id: check-changes
        shell: pwsh
        run: |
          $readmeUpdated = '${{ steps.update-readme.outputs.readme_updated }}' -eq 'true'

          # Check if packages were updated by reading the summary file
          $summaryPath = "${{ github.workspace }}\.artifacts\package-summary.txt"
          $packagesUpdated = $false
          if (Test-Path $summaryPath) {
            $content = Get-Content $summaryPath -Raw
            $packagesUpdated = $content -notmatch 'No packages to update'
          }

          Write-Host "README updated: $readmeUpdated"
          Write-Host "Packages updated: $packagesUpdated"

          if (-not $readmeUpdated -and -not $packagesUpdated) {
            Write-Host ""
            Write-Host "================================================" -ForegroundColor Green
            Write-Host "âœ… No Changes Needed - Workflow Complete" -ForegroundColor Green
            Write-Host "================================================" -ForegroundColor Green
            Write-Host ""
            Write-Host "ðŸ“‹ Summary:" -ForegroundColor Cyan
            Write-Host "  â€¢ README: Already up-to-date with latest Umbraco 13 version" -ForegroundColor Yellow
            Write-Host "  â€¢ NuGet Packages: All packages are already at their latest versions" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "No branch created, no commits made, no PR needed." -ForegroundColor Cyan
            Write-Host "================================================" -ForegroundColor Green

            echo "has_changes=false" >> $env:GITHUB_OUTPUT
            exit 0
          } else {
            echo "has_changes=true" >> $env:GITHUB_OUTPUT
          }

      - name: Commit and push changes
        id: commit-and-push
        if: ${{ github.event.inputs.dryRun != 'true' && steps.check-changes.outputs.has_changes == 'true' }}
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          $branchName = "update-nuget-packages-$(Get-Date -Format 'yyyyMMddHHmmss')"
          echo "branchName=$branchName" >> $env:GITHUB_OUTPUT

          git config user.name "Paul Seal"
          git config user.email "prjseal@gmail.com"
          git checkout -b $branchName
          git add .
          if (git diff --cached --quiet) {
            Write-Host "No changes detected. Skipping commit and PR."
            exit 0
          }

          # Determine what was updated for commit message
          $readmeUpdated = '${{ steps.update-readme.outputs.readme_updated }}' -eq 'true'
          $summaryPath = "${{ github.workspace }}\.artifacts\package-summary.txt"
          $packagesUpdated = $false
          if (Test-Path $summaryPath) {
            $content = Get-Content $summaryPath -Raw
            $packagesUpdated = $content -notmatch 'No packages to update'
          }

          # Create appropriate commit message
          if ($readmeUpdated -and -not $packagesUpdated) {
            # Only README updated - skip CI builds
            $commitMessage = "Update README with latest Umbraco 13 version [skip ci]"
            Write-Host "Only README updated - adding [skip ci] to commit message" -ForegroundColor Cyan
          } elseif (-not $readmeUpdated -and $packagesUpdated) {
            # Only packages updated
            $commitMessage = "Update NuGet packages"
          } else {
            # Both updated
            $commitMessage = "Update README and NuGet packages"
          }

          git commit -m $commitMessage
          git push https://x-access-token:$env:PAT_TOKEN@github.com/${{ github.repository }}.git $branchName

      - name: Read package summary
        id: read-summary
        run: |
          $summaryPath = "${{ github.workspace }}\.artifacts\package-summary.txt"
          if (Test-Path $summaryPath) {
            $content = Get-Content $summaryPath -Raw
            echo "summary<<EOF" >> $env:GITHUB_OUTPUT
            echo "$content" >> $env:GITHUB_OUTPUT
            echo "EOF" >> $env:GITHUB_OUTPUT
          } else {
            echo "summary<<EOF" >> $env:GITHUB_OUTPUT
            echo "No package summary found." >> $env:GITHUB_OUTPUT
            echo "EOF" >> $env:GITHUB_OUTPUT
          }

      - name: Check for existing similar PRs
        id: check-existing-pr
        if: ${{ github.event.inputs.dryRun != 'true' && steps.check-changes.outputs.has_changes == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          echo $env:GITHUB_TOKEN | gh auth login --with-token

          # Get current package summary from file
          $summaryPath = "${{ github.workspace }}\.artifacts\package-summary.txt"
          $currentSummary = Get-Content $summaryPath -Raw

          # List all open PRs with branches matching our pattern
          $existingPRs = gh pr list --state open --json number,headRefName,body --limit 100 | ConvertFrom-Json

          $skipPR = $false
          $matchingPR = $null

          foreach ($pr in $existingPRs) {
            if ($pr.headRefName -like "update-nuget-packages-*") {
              # Extract the package table from the PR body
              $prBody = $pr.body

              # Extract content between triple backticks (the package table)
              if ($prBody -match '(?s)```(.+?)```') {
                $prPackages = $matches[1].Trim()

                # Compare with current summary (normalize whitespace for comparison)
                $currentNormalized = $currentSummary.Trim() -replace '\s+', ' '
                $prNormalized = $prPackages -replace '\s+', ' '

                if ($currentNormalized -eq $prNormalized) {
                  $skipPR = $true
                  $matchingPR = $pr.number
                  Write-Host "Found existing PR #$matchingPR with identical package updates. Skipping PR creation."
                  break
                }
              }
            }
          }

          echo "skip=$skipPR" >> $env:GITHUB_OUTPUT
          echo "existing_pr_number=$matchingPR" >> $env:GITHUB_OUTPUT

      - name: Create Pull Request
        if: ${{ github.event.inputs.dryRun != 'true' && steps.check-changes.outputs.has_changes == 'true' && steps.check-existing-pr.outputs.skip != 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          echo $env:GITHUB_TOKEN | gh auth login --with-token

          # Create PR body in a file to avoid escaping issues
          $prBodyFile = "${{ github.workspace }}\.artifacts\pr-body.md"

          # Determine what was updated
          $readmeUpdated = '${{ steps.update-readme.outputs.readme_updated }}' -eq 'true'
          $summaryContent = '${{ steps.read-summary.outputs.summary }}'
          $packagesUpdated = ($summaryContent -notmatch 'No package summary found') -and ($summaryContent -notmatch 'No packages to update')

          # Write PR body content line by line
          "This PR updates the following:" | Out-File -FilePath $prBodyFile -Encoding UTF8
          "" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append

          if ($readmeUpdated) {
            "- âœ… **README.md** - Updated with latest Umbraco 13 version" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append
          }
          if ($packagesUpdated) {
            "- âœ… **NuGet Packages** - Updated to latest versions" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append
          }

          "" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append
          "**Triggered by:** ${{ github.actor }}" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append

          if ($packagesUpdated) {
            "" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append
            "**IncludePrerelease:** ${{ github.event.inputs.includePrerelease }}" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append
            "" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append
            "### Updated Packages:" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append
            "``````" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append
            "${{ steps.read-summary.outputs.summary }}" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append
            "``````" | Out-File -FilePath $prBodyFile -Encoding UTF8 -Append
          }

          gh pr create `
            --title "Update NuGet packages" `
            --body-file $prBodyFile `
            --base main `
            --head ${{ steps.commit-and-push.outputs.branchName }}

      - name: Summary - PR Skipped
        if: ${{ github.event.inputs.dryRun != 'true' && steps.check-changes.outputs.has_changes == 'true' && steps.check-existing-pr.outputs.skip == 'true' }}
        run: |
          Write-Host "================================================" -ForegroundColor Yellow
          Write-Host "PR CREATION SKIPPED" -ForegroundColor Yellow
          Write-Host "================================================" -ForegroundColor Yellow
          Write-Host ""
          Write-Host "An existing PR (#${{ steps.check-existing-pr.outputs.existing_pr_number }}) already has identical package updates." -ForegroundColor Cyan
          Write-Host "No need to create a duplicate PR." -ForegroundColor Cyan
          Write-Host ""
          Write-Host "Existing PR: https://github.com/${{ github.repository }}/pull/${{ steps.check-existing-pr.outputs.existing_pr_number }}" -ForegroundColor Green
          Write-Host "================================================" -ForegroundColor Yellow
