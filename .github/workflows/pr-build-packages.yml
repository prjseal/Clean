name: PR - Build NuGet Packages

on:
  pull_request:
    branches:
      - main

jobs:
  build-packages:
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Get latest NuGet version and create build version
        id: version
        shell: pwsh
        run: |
          # Query NuGet API for the latest version of the Clean package
          $packageId = "Clean"
          $nugetApiUrl = "https://api.nuget.org/v3-flatcontainer/$packageId/index.json"

          Write-Host "Fetching latest version for package: $packageId"

          try {
            $response = Invoke-RestMethod -Uri $nugetApiUrl -ErrorAction Stop
            $versions = $response.versions

            Write-Host "Found $($versions.Count) total versions"

            # Parse and sort versions using semantic versioning
            $parsedVersions = $versions | ForEach-Object {
              $versionString = $_
              $prerelease = ""

              # Split on hyphen to separate version from prerelease tag
              if ($versionString -match '^([0-9]+\.[0-9]+\.[0-9]+)(.*)$') {
                $baseVersion = $matches[1]
                $prerelease = $matches[2]
              } else {
                $baseVersion = $versionString
              }

              # Create object for sorting
              [PSCustomObject]@{
                Original = $versionString
                Version = [Version]$baseVersion
                Prerelease = $prerelease
                IsPrerelease = $prerelease -ne ""
              }
            }

            # Sort by version (descending), then by prerelease status (stable first)
            # This ensures 7.0.0 comes before 7.0.0-rc, but 7.0.0-rc comes before 6.x.x
            $sortedVersions = $parsedVersions | Sort-Object -Property @{Expression={$_.Version}; Descending=$true}, @{Expression={$_.IsPrerelease}; Descending=$false}

            # Get the highest version (could be stable or prerelease)
            $latestVersion = $sortedVersions[0].Original

            # Strip prerelease suffix (everything from - onwards) for the base version
            $baseVersionOnly = $sortedVersions[0].Version

            # If there's no prerelease suffix, increment the patch version
            if (-not $sortedVersions[0].IsPrerelease) {
              $major = $baseVersionOnly.Major
              $minor = $baseVersionOnly.Minor
              $patch = $baseVersionOnly.Build + 1
              $baseVersionOnly = [Version]::new($major, $minor, $patch)
              Write-Host "Latest is stable release, incrementing patch version"
            } else {
              Write-Host "Latest is prerelease, using base version without suffix"
            }

            $baseVersionString = $baseVersionOnly.ToString()

            Write-Host "Latest version found: $latestVersion"
            Write-Host "  Version number: $($sortedVersions[0].Version)"
            Write-Host "  Is prerelease: $($sortedVersions[0].IsPrerelease)"
            Write-Host "  Base version for builds: $baseVersionString"

            # Create build version: {baseVersionString}-ci.{buildNumber}
            $buildNumber = "${{ github.run_number }}"
            $buildVersion = "$baseVersionString-ci.$buildNumber"

            Write-Host "Build version: $buildVersion"

            # Output the version for use in subsequent steps
            echo "version=$buildVersion" >> $env:GITHUB_OUTPUT
            echo "base_version=$baseVersionString" >> $env:GITHUB_OUTPUT
          }
          catch {
            Write-Host "Error fetching version from NuGet: $_"
            $buildNumber = "${{ github.run_number }}"
            $buildVersion = "1.0.0-ci.$buildNumber"
            Write-Host "Using default version: $buildVersion"
            echo "version=$buildVersion" >> $env:GITHUB_OUTPUT
            echo "base_version=1.0.0" >> $env:GITHUB_OUTPUT
          }

      - name: Display version info
        run: |
          Write-Host "================================================" -ForegroundColor Cyan
          Write-Host "Build Version Information" -ForegroundColor Cyan
          Write-Host "================================================" -ForegroundColor Cyan
          Write-Host "Base Version: ${{ steps.version.outputs.base_version }}" -ForegroundColor Green
          Write-Host "Build Number: ${{ github.run_number }}" -ForegroundColor Green
          Write-Host "Full Version: ${{ steps.version.outputs.version }}" -ForegroundColor Yellow
          Write-Host "================================================" -ForegroundColor Cyan

      - name: Run CreateNuGetPackages script
        shell: pwsh
        run: |
          Write-Host "Running CreateNuGetPackages.ps1 with version ${{ steps.version.outputs.version }}"
          ./CreateNuGetPackages.ps1 -Version "${{ steps.version.outputs.version }}"

      - name: Upload NuGet packages as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nuget-packages-${{ steps.version.outputs.version }}
          path: .artifacts/nuget/*.nupkg
          if-no-files-found: warn

      - name: Publish to GitHub Packages
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "================================================" -ForegroundColor Cyan
          Write-Host "Publishing NuGet Packages to GitHub Packages" -ForegroundColor Cyan
          Write-Host "================================================" -ForegroundColor Cyan

          # Get all package files
          $packages = Get-ChildItem -Path ".artifacts/nuget/*.nupkg" -ErrorAction SilentlyContinue

          if (-not $packages) {
            Write-Host "No packages found to publish." -ForegroundColor Yellow
            exit 0
          }

          Write-Host "Found $($packages.Count) package(s) to publish:" -ForegroundColor Green
          foreach ($pkg in $packages) {
            Write-Host "  - $($pkg.Name)" -ForegroundColor White
          }
          Write-Host ""

          # Add GitHub Packages source
          $sourceUrl = "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json"
          Write-Host "Adding GitHub Packages source: $sourceUrl" -ForegroundColor Cyan
          dotnet nuget add source $sourceUrl --name "GitHubPackages" --username "${{ github.repository_owner }}" --password "$env:GITHUB_TOKEN" --store-password-in-clear-text

          # Push each package
          foreach ($pkg in $packages) {
            Write-Host "Publishing $($pkg.Name)..." -ForegroundColor Cyan
            dotnet nuget push $pkg.FullName --source "GitHubPackages" --api-key "$env:GITHUB_TOKEN" --skip-duplicate

            if ($LASTEXITCODE -eq 0) {
              Write-Host "✅ Successfully published $($pkg.Name)" -ForegroundColor Green
            } else {
              Write-Host "⚠️  Failed to publish $($pkg.Name) (exit code: $LASTEXITCODE)" -ForegroundColor Yellow
            }
          }

          Write-Host ""
          Write-Host "================================================" -ForegroundColor Cyan
          Write-Host "Package Publishing Complete" -ForegroundColor Cyan
          Write-Host "================================================" -ForegroundColor Cyan

      - name: Test Package Installation and Site
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "================================================" -ForegroundColor Cyan
          Write-Host "Testing Package Installation from GitHub Packages" -ForegroundColor Cyan
          Write-Host "================================================" -ForegroundColor Cyan

          # Create test directory
          $testDir = "${{ github.workspace }}\test-installation"
          if (Test-Path $testDir) {
            Remove-Item $testDir -Recurse -Force
          }
          New-Item -ItemType Directory -Path $testDir | Out-Null
          Set-Location $testDir

          # Configure GitHub Packages as NuGet source
          Write-Host "`nConfiguring GitHub Packages as NuGet source..." -ForegroundColor Yellow
          $sourceUrl = "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json"
          dotnet nuget add source $sourceUrl --name "GitHubPackages" --username "${{ github.repository_owner }}" --password "$env:GITHUB_TOKEN" --store-password-in-clear-text

          # Read Umbraco version from Clean.csproj to determine which template version to use
          Write-Host "`nDetermining Umbraco version from Clean package..." -ForegroundColor Yellow
          $cleanCsprojPath = "${{ github.workspace }}\template\Clean\Clean.csproj"
          [xml]$cleanCsproj = Get-Content $cleanCsprojPath
          $umbracoPackageRef = $cleanCsproj.Project.ItemGroup.PackageReference | Where-Object { $_.Include -eq "Umbraco.Cms.Web.Website" }
          $umbracoVersion = $umbracoPackageRef.Version
          Write-Host "Umbraco version: $umbracoVersion" -ForegroundColor Green

          # Install Umbraco templates for the detected version
          Write-Host "`nInstalling Umbraco templates version $umbracoVersion..." -ForegroundColor Yellow
          dotnet new install Umbraco.Templates::$umbracoVersion --force

          # Create Umbraco project
          Write-Host "`nCreating test Umbraco project..." -ForegroundColor Yellow
          dotnet new sln --name "TestSolution"
          dotnet new umbraco --force -n "TestProject" --friendly-name "Administrator" --email "admin@example.com" --password "1234567890" --development-database-type SQLite
          dotnet sln add "TestProject"

          # Install Clean package from GitHub Packages
          Write-Host "`nInstalling Clean package version ${{ steps.version.outputs.version }} from GitHub Packages..." -ForegroundColor Yellow
          dotnet add "TestProject" package Clean --version "${{ steps.version.outputs.version }}" --source "GitHubPackages"

          # Start the site in background
          Write-Host "`nStarting Umbraco site..." -ForegroundColor Yellow
          $logFile = "$testDir\site.log"
          $errFile = "$testDir\site.err"

          $process = Start-Process -FilePath "dotnet" `
            -ArgumentList "run --project TestProject" `
            -RedirectStandardOutput $logFile `
            -RedirectStandardError $errFile `
            -NoNewWindow `
            -PassThru

          Write-Host "Site process started with PID: $($process.Id)" -ForegroundColor Green

          # Wait for site to start and extract URL
          $startTime = Get-Date
          $timeoutSeconds = 180
          $siteStarted = $false
          $siteUrl = $null

          Write-Host "Waiting for site to start (timeout: ${timeoutSeconds}s)..." -ForegroundColor Yellow

          while (-not $siteStarted) {
            if ((Get-Date) - $startTime -gt (New-TimeSpan -Seconds $timeoutSeconds)) {
              Write-Host "Timeout reached! Site failed to start." -ForegroundColor Red
              if (-not $process.HasExited) {
                Stop-Process -Id $process.Id -Force
              }
              exit 1
            }

            if (Test-Path $logFile) {
              $logContent = Get-Content $logFile -Raw

              # Check if site is listening on HTTPS
              if ($logContent -match "Now listening on:\s*(https://[^\s]+)") {
                $siteUrl = $matches[1]
                $siteStarted = $true
                Write-Host "Site is running at: $siteUrl" -ForegroundColor Green
                break
              }
            }

            Start-Sleep -Seconds 2
          }

          # Install Node.js dependencies for Playwright
          Write-Host "`nInstalling Playwright..." -ForegroundColor Yellow
          npm init -y
          npm install --save-dev playwright

          # Install Playwright browsers
          Write-Host "Installing Playwright browsers..." -ForegroundColor Yellow
          npx playwright install chromium

          # Create Playwright test script
          Write-Host "`nCreating Playwright test script..." -ForegroundColor Yellow
          $testScript = @"
const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');

(async () => {
  const browser = await chromium.launch();
  const context = await browser.newContext({
    ignoreHTTPSErrors: true
  });
  const page = await context.newPage();

  const screenshotsDir = path.join(__dirname, 'screenshots');
  if (!fs.existsSync(screenshotsDir)) {
    fs.mkdirSync(screenshotsDir, { recursive: true });
  }

  const baseUrl = process.env.SITE_URL || '$siteUrl';
  console.log('Testing site at:', baseUrl);

  // Define pages to test
  const pages = [
    { name: 'home', url: baseUrl },
    { name: 'umbraco-login', url: baseUrl + '/umbraco' },
  ];

  // Navigate to home page first to discover links
  try {
    console.log('Navigating to home page...');
    await page.goto(baseUrl, { waitUntil: 'networkidle', timeout: 30000 });

    // Take screenshot of home page
    await page.screenshot({
      path: path.join(screenshotsDir, '01-home.png'),
      fullPage: true
    });
    console.log('Screenshot saved: 01-home.png');

    // Find all internal links on the page
    const links = await page.evaluate((baseUrl) => {
      const anchors = Array.from(document.querySelectorAll('a[href]'));
      return anchors
        .map(a => a.href)
        .filter(href => {
          try {
            const url = new URL(href);
            const baseUrlObj = new URL(baseUrl);
            return url.hostname === baseUrlObj.hostname &&
                   !href.includes('/umbraco') &&
                   !href.includes('#') &&
                   !href.includes('javascript:');
          } catch {
            return false;
          }
        })
        .filter((value, index, self) => self.indexOf(value) === index); // unique
    }, baseUrl);

    console.log('Found ' + links.length + ' internal links to test');

    // Visit each discovered link
    let counter = 2;
    for (const link of links.slice(0, 10)) { // Limit to 10 pages to avoid timeout
      try {
        console.log('Navigating to:', link);
        await page.goto(link, { waitUntil: 'networkidle', timeout: 30000 });

        const screenshotName = counter.toString().padStart(2, '0') + '-' +
          link.replace(baseUrl, '').replace(/[^a-z0-9]/gi, '-').substring(0, 50) + '.png';

        await page.screenshot({
          path: path.join(screenshotsDir, screenshotName),
          fullPage: true
        });
        console.log('Screenshot saved:', screenshotName);
        counter++;
      } catch (error) {
        console.error('Error visiting', link, ':', error.message);
      }
    }

    // Test Umbraco login page
    console.log('Navigating to Umbraco login...');
    await page.goto(baseUrl + '/umbraco', { waitUntil: 'networkidle', timeout: 30000 });
    await page.screenshot({
      path: path.join(screenshotsDir, counter.toString().padStart(2, '0') + '-umbraco-login.png'),
      fullPage: true
    });
    console.log('Screenshot saved: umbraco-login.png');

  } catch (error) {
    console.error('Error during testing:', error);
    process.exit(1);
  }

  await browser.close();
  console.log('Testing complete!');
})();
"@

          $testScript | Out-File -FilePath "$testDir\test.js" -Encoding UTF8

          # Run Playwright tests
          Write-Host "`nRunning Playwright tests..." -ForegroundColor Yellow
          `$env:SITE_URL = "$siteUrl"
          node test.js

          # Stop the site process
          Write-Host "`nStopping site process..." -ForegroundColor Yellow
          if (-not $process.HasExited) {
            Stop-Process -Id $process.Id -Force
            Write-Host "Site process stopped" -ForegroundColor Green
          }

          Write-Host "`n================================================" -ForegroundColor Cyan
          Write-Host "Package Testing Complete" -ForegroundColor Cyan
          Write-Host "================================================" -ForegroundColor Cyan

      - name: Upload Screenshots
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-screenshots-${{ steps.version.outputs.version }}
          path: test-installation/screenshots/*.png
          if-no-files-found: warn

      - name: Build Summary
        if: always()
        run: |
          Write-Host "================================================" -ForegroundColor Green
          Write-Host "Build Summary" -ForegroundColor Green
          Write-Host "================================================" -ForegroundColor Green
          Write-Host "Version: ${{ steps.version.outputs.version }}" -ForegroundColor Cyan
          Write-Host "PR Number: ${{ github.event.pull_request.number }}" -ForegroundColor Cyan
          Write-Host "Branch: ${{ github.head_ref }}" -ForegroundColor Cyan
          Write-Host "Triggered by: ${{ github.actor }}" -ForegroundColor Cyan
          Write-Host "================================================" -ForegroundColor Green

          # List generated packages
          $packages = Get-ChildItem -Path ".artifacts/nuget/*.nupkg" -ErrorAction SilentlyContinue
          if ($packages) {
            Write-Host "`nGenerated Packages:" -ForegroundColor Yellow
            foreach ($pkg in $packages) {
              Write-Host "  - $($pkg.Name)" -ForegroundColor White
            }
            Write-Host "`nPublished to: https://github.com/${{ github.repository }}/packages" -ForegroundColor Cyan
          } else {
            Write-Host "`nNo packages were generated." -ForegroundColor Red
          }
